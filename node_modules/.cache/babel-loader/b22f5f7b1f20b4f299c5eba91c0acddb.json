{"ast":null,"code":"function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _extends2() {\n  _extends2 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends2.apply(this, arguments);\n} // Generated with Packemon: https://packemon.dev\n// Platform: browser, Support: stable, Format: esm\n\n\nimport React from 'react';\nimport escapeHtml from 'escape-html';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction Element(_ref) {\n  var _ref$attributes = _ref.attributes,\n      attributes = _ref$attributes === void 0 ? {} : _ref$attributes,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? null : _ref$children,\n      _ref$selfClose = _ref.selfClose,\n      selfClose = _ref$selfClose === void 0 ? false : _ref$selfClose,\n      tagName = _ref.tagName;\n  var Tag = tagName;\n  return selfClose ? /*#__PURE__*/React.createElement(Tag, _extends({\n    className: className\n  }, attributes)) : /*#__PURE__*/React.createElement(Tag, _extends({\n    className: className\n  }, attributes), children);\n}\n\nvar Filter = /*#__PURE__*/function () {\n  function Filter() {}\n\n  var _proto = Filter.prototype;\n  /**\n   * Filter and clean an HTML attribute value.\n   */\n\n  _proto.attribute = function attribute(name, value) {\n    return value;\n  }\n  /**\n   * Filter and clean an HTML node.\n   */\n  ;\n\n  _proto.node = function node(name, _node) {\n    return _node;\n  };\n\n  return Filter;\n}();\n/* eslint-disable no-bitwise, no-magic-numbers, sort-keys */\n// https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories\n\n\nvar TYPE_FLOW = 1;\nvar TYPE_SECTION = 1 << 1;\nvar TYPE_HEADING = 1 << 2;\nvar TYPE_PHRASING = 1 << 3;\nvar TYPE_EMBEDDED = 1 << 4;\nvar TYPE_INTERACTIVE = 1 << 5;\nvar TYPE_PALPABLE = 1 << 6; // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n\nvar tagConfigs = {\n  a: {\n    content: TYPE_FLOW | TYPE_PHRASING,\n    self: false,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  address: {\n    invalid: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'address', 'article', 'aside', 'section', 'div', 'header', 'footer'],\n    self: false\n  },\n  audio: {\n    children: ['track', 'source']\n  },\n  br: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true\n  },\n  body: {\n    content: TYPE_FLOW | TYPE_SECTION | TYPE_HEADING | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  button: {\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  caption: {\n    content: TYPE_FLOW,\n    parent: ['table']\n  },\n  col: {\n    parent: ['colgroup'],\n    void: true\n  },\n  colgroup: {\n    children: ['col'],\n    parent: ['table']\n  },\n  details: {\n    children: ['summary'],\n    type: TYPE_FLOW | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  dd: {\n    content: TYPE_FLOW,\n    parent: ['dl']\n  },\n  dl: {\n    children: ['dt', 'dd'],\n    type: TYPE_FLOW\n  },\n  dt: {\n    content: TYPE_FLOW,\n    invalid: ['footer', 'header'],\n    parent: ['dl']\n  },\n  figcaption: {\n    content: TYPE_FLOW,\n    parent: ['figure']\n  },\n  footer: {\n    invalid: ['footer', 'header']\n  },\n  header: {\n    invalid: ['footer', 'header']\n  },\n  hr: {\n    type: TYPE_FLOW,\n    void: true\n  },\n  img: {\n    void: true\n  },\n  li: {\n    content: TYPE_FLOW,\n    parent: ['ul', 'ol', 'menu']\n  },\n  main: {\n    self: false\n  },\n  ol: {\n    children: ['li'],\n    type: TYPE_FLOW\n  },\n  picture: {\n    children: ['source', 'img'],\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED\n  },\n  rb: {\n    parent: ['ruby', 'rtc']\n  },\n  rp: {\n    parent: ['ruby', 'rtc']\n  },\n  rt: {\n    content: TYPE_PHRASING,\n    parent: ['ruby', 'rtc']\n  },\n  rtc: {\n    content: TYPE_PHRASING,\n    parent: ['ruby']\n  },\n  ruby: {\n    children: ['rb', 'rp', 'rt', 'rtc']\n  },\n  source: {\n    parent: ['audio', 'video', 'picture'],\n    void: true\n  },\n  summary: {\n    content: TYPE_PHRASING,\n    parent: ['details']\n  },\n  table: {\n    children: ['caption', 'colgroup', 'thead', 'tbody', 'tfoot', 'tr'],\n    type: TYPE_FLOW\n  },\n  tbody: {\n    parent: ['table'],\n    children: ['tr']\n  },\n  td: {\n    content: TYPE_FLOW,\n    parent: ['tr']\n  },\n  tfoot: {\n    parent: ['table'],\n    children: ['tr']\n  },\n  th: {\n    content: TYPE_FLOW,\n    parent: ['tr']\n  },\n  thead: {\n    parent: ['table'],\n    children: ['tr']\n  },\n  tr: {\n    parent: ['table', 'tbody', 'thead', 'tfoot'],\n    children: ['th', 'td']\n  },\n  track: {\n    parent: ['audio', 'video'],\n    void: true\n  },\n  ul: {\n    children: ['li'],\n    type: TYPE_FLOW\n  },\n  video: {\n    children: ['track', 'source']\n  },\n  wbr: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true\n  }\n};\n\nfunction createConfigBuilder(config) {\n  return function (tagName) {\n    tagConfigs[tagName] = _extends2({}, config, tagConfigs[tagName]);\n  };\n}\n\n['address', 'main', 'div', 'figure', 'p', 'pre'].forEach(createConfigBuilder({\n  content: TYPE_FLOW,\n  type: TYPE_FLOW | TYPE_PALPABLE\n}));\n['abbr', 'b', 'bdi', 'bdo', 'cite', 'code', 'data', 'dfn', 'em', 'i', 'kbd', 'mark', 'q', 'ruby', 'samp', 'strong', 'sub', 'sup', 'time', 'u', 'var'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_PHRASING | TYPE_PALPABLE\n}));\n['p', 'pre'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_PALPABLE\n}));\n['s', 'small', 'span', 'del', 'ins'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_PHRASING\n}));\n['article', 'aside', 'footer', 'header', 'nav', 'section', 'blockquote'].forEach(createConfigBuilder({\n  content: TYPE_FLOW,\n  type: TYPE_FLOW | TYPE_SECTION | TYPE_PALPABLE\n}));\n['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_HEADING | TYPE_PALPABLE\n}));\n['audio', 'canvas', 'iframe', 'img', 'video'].forEach(createConfigBuilder({\n  type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_PALPABLE\n})); // Disable this map from being modified\n\nvar TAGS = Object.freeze(tagConfigs); // Tags that should never be allowed, even if the allow list is disabled\n\nvar BANNED_TAG_LIST = ['applet', 'base', 'body', 'command', 'embed', 'frame', 'frameset', 'head', 'html', 'link', 'meta', 'noscript', 'object', 'script', 'style', 'title'];\nvar ALLOWED_TAG_LIST = Object.keys(TAGS).filter(function (tag) {\n  return tag !== 'canvas' && tag !== 'iframe';\n}); // Filters apply to HTML attributes\n\nvar FILTER_ALLOW = 1;\nvar FILTER_DENY = 2;\nvar FILTER_CAST_NUMBER = 3;\nvar FILTER_CAST_BOOL = 4;\nvar FILTER_NO_CAST = 5; // Attributes not listed here will be denied\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n\nvar ATTRIBUTES = Object.freeze({\n  alt: FILTER_ALLOW,\n  cite: FILTER_ALLOW,\n  class: FILTER_ALLOW,\n  colspan: FILTER_CAST_NUMBER,\n  controls: FILTER_CAST_BOOL,\n  datetime: FILTER_ALLOW,\n  default: FILTER_CAST_BOOL,\n  disabled: FILTER_CAST_BOOL,\n  dir: FILTER_ALLOW,\n  height: FILTER_ALLOW,\n  href: FILTER_ALLOW,\n  id: FILTER_ALLOW,\n  kind: FILTER_ALLOW,\n  label: FILTER_ALLOW,\n  lang: FILTER_ALLOW,\n  loading: FILTER_ALLOW,\n  loop: FILTER_CAST_BOOL,\n  media: FILTER_ALLOW,\n  muted: FILTER_CAST_BOOL,\n  poster: FILTER_ALLOW,\n  role: FILTER_ALLOW,\n  rowspan: FILTER_CAST_NUMBER,\n  scope: FILTER_ALLOW,\n  sizes: FILTER_ALLOW,\n  span: FILTER_CAST_NUMBER,\n  start: FILTER_CAST_NUMBER,\n  style: FILTER_NO_CAST,\n  src: FILTER_ALLOW,\n  srclang: FILTER_ALLOW,\n  srcset: FILTER_ALLOW,\n  target: FILTER_ALLOW,\n  title: FILTER_ALLOW,\n  type: FILTER_ALLOW,\n  width: FILTER_ALLOW\n}); // Attributes to camel case for React props\n\nvar ATTRIBUTES_TO_PROPS = Object.freeze({\n  class: 'className',\n  colspan: 'colSpan',\n  datetime: 'dateTime',\n  rowspan: 'rowSpan',\n  srclang: 'srcLang',\n  srcset: 'srcSet'\n});\nvar INVALID_STYLES = /(url|image|image-set)\\(/i;\n\nvar StyleFilter = /*#__PURE__*/function (_Filter) {\n  _inheritsLoose(StyleFilter, _Filter);\n\n  function StyleFilter() {\n    return _Filter.apply(this, arguments) || this;\n  }\n\n  var _proto2 = StyleFilter.prototype;\n\n  _proto2.attribute = function attribute(name, value) {\n    if (name === 'style') {\n      Object.keys(value).forEach(function (key) {\n        if (String(value[key]).match(INVALID_STYLES)) {\n          // eslint-disable-next-line no-param-reassign\n          delete value[key];\n        }\n      });\n    }\n\n    return value;\n  };\n\n  return StyleFilter;\n}(Filter);\n/* eslint-disable no-bitwise, no-cond-assign, complexity */\n\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nvar ALLOWED_ATTRS = /^(aria\\x2D|data\\x2D|[0-9A-Z_a-z\\u017F\\u212A]+:)/i;\nvar OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\n\nfunction createDocument() {\n  // Maybe SSR? Just do nothing instead of crashing!\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return undefined;\n  }\n\n  return document.implementation.createHTMLDocument('Interweave');\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(markup, props, matchers, filters) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (matchers === void 0) {\n      matchers = [];\n    }\n\n    if (filters === void 0) {\n      filters = [];\n    }\n\n    this.allowed = void 0;\n    this.banned = void 0;\n    this.blocked = void 0;\n    this.container = void 0;\n    this.content = [];\n    this.props = void 0;\n    this.matchers = void 0;\n    this.filters = void 0;\n    this.keyIndex = void 0;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (markup && typeof markup !== 'string') {\n        throw new TypeError('Interweave parser requires a valid string.');\n      }\n    }\n\n    this.props = props;\n    this.matchers = matchers;\n    this.filters = [].concat(filters, [new StyleFilter()]);\n    this.keyIndex = -1;\n    this.container = this.createContainer(markup || '');\n    this.allowed = new Set(props.allowList || ALLOWED_TAG_LIST);\n    this.banned = new Set(BANNED_TAG_LIST);\n    this.blocked = new Set(props.blockList);\n  }\n  /**\n   * Loop through and apply all registered attribute filters.\n   */\n\n\n  var _proto3 = Parser.prototype;\n\n  _proto3.applyAttributeFilters = function applyAttributeFilters(name, value) {\n    return this.filters.reduce(function (nextValue, filter) {\n      return nextValue !== null && typeof filter.attribute === 'function' ? filter.attribute(name, nextValue) : nextValue;\n    }, value);\n  }\n  /**\n   * Loop through and apply all registered node filters.\n   */\n  ;\n\n  _proto3.applyNodeFilters = function applyNodeFilters(name, node) {\n    // Allow null to be returned\n    return this.filters.reduce(function (nextNode, filter) {\n      return nextNode !== null && typeof filter.node === 'function' ? filter.node(name, nextNode) : nextNode;\n    }, node);\n  }\n  /**\n   * Loop through and apply all registered matchers to the string.\n   * If a match is found, create a React element, and build a new array.\n   * This array allows React to interpolate and render accordingly.\n   */\n  ;\n\n  _proto3.applyMatchers = function applyMatchers(string, parentConfig) {\n    var _this = this;\n\n    var elements = {};\n    var props = this.props;\n    var matchedString = string;\n    var elementIndex = 0;\n    var parts = null;\n    this.matchers.forEach(function (matcher) {\n      var tagName = matcher.asTag().toLowerCase();\n\n      var config = _this.getTagConfig(tagName); // Skip matchers that have been disabled from props or are not supported\n\n\n      if (props[matcher.inverseName] || !_this.isTagAllowed(tagName)) {\n        return;\n      } // Skip matchers in which the child cannot be rendered\n\n\n      if (!_this.canRenderChild(parentConfig, config)) {\n        return;\n      } // Continuously trigger the matcher until no matches are found\n\n\n      var tokenizedString = '';\n\n      while (matchedString && (parts = matcher.match(matchedString))) {\n        var _parts = parts,\n            index = _parts.index,\n            length = _parts.length,\n            _match = _parts.match,\n            valid = _parts.valid,\n            isVoid = _parts.void,\n            partProps = _objectWithoutPropertiesLoose(_parts, [\"index\", \"length\", \"match\", \"valid\", \"void\"]);\n\n        var tokenName = matcher.propName + elementIndex; // Piece together a new string with interpolated tokens\n\n        if (index > 0) {\n          tokenizedString += matchedString.slice(0, index);\n        }\n\n        if (valid) {\n          tokenizedString += isVoid ? \"{{{\" + tokenName + \"/}}}\" : \"{{{\" + tokenName + \"}}}\" + _match + \"{{{/\" + tokenName + \"}}}\";\n          _this.keyIndex += 1;\n          elementIndex += 1;\n          elements[tokenName] = {\n            children: _match,\n            matcher: matcher,\n            props: _extends2({}, props, partProps, {\n              key: _this.keyIndex\n            })\n          };\n        } else {\n          tokenizedString += _match;\n        } // Reduce the string being matched against,\n        // otherwise we end up in an infinite loop!\n\n\n        if (matcher.greedy) {\n          matchedString = tokenizedString + matchedString.slice(index + length);\n          tokenizedString = '';\n        } else {\n          // eslint-disable-next-line unicorn/explicit-length-check\n          matchedString = matchedString.slice(index + (length || _match.length));\n        }\n      } // Update the matched string with the tokenized string,\n      // so that the next matcher can apply to it.\n\n\n      if (!matcher.greedy) {\n        matchedString = tokenizedString + matchedString;\n      }\n    });\n\n    if (elementIndex === 0) {\n      return string;\n    }\n\n    return this.replaceTokens(matchedString, elements);\n  }\n  /**\n   * Determine whether the child can be rendered within the parent.\n   */\n  ;\n\n  _proto3.canRenderChild = function canRenderChild(parentConfig, childConfig) {\n    if (!parentConfig.tagName || !childConfig.tagName) {\n      return false;\n    } // No children\n\n\n    if (parentConfig.void) {\n      return false;\n    } // Valid children\n\n\n    if (parentConfig.children.length > 0) {\n      return parentConfig.children.includes(childConfig.tagName);\n    }\n\n    if (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n      return false;\n    } // Valid parent\n\n\n    if (childConfig.parent.length > 0) {\n      return childConfig.parent.includes(parentConfig.tagName);\n    } // Self nesting\n\n\n    if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n      return false;\n    } // Content category type\n\n\n    return Boolean(parentConfig && parentConfig.content & childConfig.type);\n  }\n  /**\n   * Convert line breaks in a string to HTML `<br/>` tags.\n   * If the string contains HTML, we should not convert anything,\n   * as line breaks should be handled by `<br/>`s in the markup itself.\n   */\n  ;\n\n  _proto3.convertLineBreaks = function convertLineBreaks(markup) {\n    var _this$props = this.props,\n        noHtml = _this$props.noHtml,\n        disableLineBreaks = _this$props.disableLineBreaks;\n\n    if (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n      return markup;\n    } // Replace carriage returns\n\n\n    var nextMarkup = markup.replace(/\\r\\n/g, '\\n'); // Replace long line feeds\n\n    nextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n'); // Replace line feeds with `<br/>`s\n\n    nextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n    return nextMarkup;\n  }\n  /**\n   * Create a detached HTML document that allows for easy HTML\n   * parsing while not triggering scripts or loading external\n   * resources.\n   */\n  ;\n\n  _proto3.createContainer = function createContainer(markup) {\n    var factory = typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL || createDocument;\n    var doc = factory();\n\n    if (!doc) {\n      return undefined;\n    }\n\n    var tag = this.props.containerTagName || 'body';\n    var el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n\n    if (markup.match(INVALID_ROOTS)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        throw new Error('HTML documents as Interweave content are not supported.');\n      }\n    } else {\n      el.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n    }\n\n    return el;\n  }\n  /**\n   * Convert an elements attribute map to an object map.\n   * Returns null if no attributes are defined.\n   */\n  ;\n\n  _proto3.extractAttributes = function extractAttributes(node) {\n    var _this2 = this;\n\n    var allowAttributes = this.props.allowAttributes;\n    var attributes = {};\n    var count = 0;\n\n    if (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n      return null;\n    }\n\n    Array.from(node.attributes).forEach(function (attr) {\n      var name = attr.name,\n          value = attr.value;\n      var newName = name.toLowerCase();\n      var filter = ATTRIBUTES[newName] || ATTRIBUTES[name]; // Verify the node is safe from attacks\n\n      if (!_this2.isSafe(node)) {\n        return;\n      } // Do not allow denied attributes, excluding ARIA attributes\n      // Do not allow events or XSS injections\n\n\n      if (!newName.match(ALLOWED_ATTRS)) {\n        if (!allowAttributes && (!filter || filter === FILTER_DENY) || newName.startsWith('on') || value.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i)) {\n          return;\n        }\n      } // Apply attribute filters\n\n\n      var newValue = newName === 'style' ? _this2.extractStyleAttribute(node) : value; // Cast to boolean\n\n      if (filter === FILTER_CAST_BOOL) {\n        newValue = true; // Cast to number\n      } else if (filter === FILTER_CAST_NUMBER) {\n        newValue = Number.parseFloat(String(newValue)); // Cast to string\n      } else if (filter !== FILTER_NO_CAST) {\n        newValue = String(newValue);\n      }\n\n      attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = _this2.applyAttributeFilters(newName, newValue);\n      count += 1;\n    });\n\n    if (count === 0) {\n      return null;\n    }\n\n    return attributes;\n  }\n  /**\n   * Extract the style attribute as an object and remove values that allow for attack vectors.\n   */\n  ;\n\n  _proto3.extractStyleAttribute = function extractStyleAttribute(node) {\n    var styles = {};\n    Array.from(node.style).forEach(function (key) {\n      var value = node.style[key];\n\n      if (typeof value === 'string' || typeof value === 'number') {\n        styles[key.replace(/-([a-z])/g, function (match, letter) {\n          return letter.toUpperCase();\n        })] = value;\n      }\n    });\n    return styles;\n  }\n  /**\n   * Return configuration for a specific tag.\n   */\n  ;\n\n  _proto3.getTagConfig = function getTagConfig(tagName) {\n    var common = {\n      children: [],\n      content: 0,\n      invalid: [],\n      parent: [],\n      self: true,\n      tagName: '',\n      type: 0,\n      void: false\n    }; // Only spread when a tag config exists,\n    // otherwise we use the empty `tagName`\n    // for parent config inheritance.\n\n    if (TAGS[tagName]) {\n      return _extends2({}, common, TAGS[tagName], {\n        tagName: tagName\n      });\n    }\n\n    return common;\n  }\n  /**\n   * Verify that a node is safe from XSS and injection attacks.\n   */\n  ;\n\n  _proto3.isSafe = function isSafe(node) {\n    // URLs should only support HTTP, email and phone numbers\n    if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n      var href = node.getAttribute('href'); // Fragment protocols start with about:\n      // So let's just allow them\n\n      if (href && href.charAt(0) === '#') {\n        return true;\n      }\n\n      var protocol = node.protocol.toLowerCase();\n      return protocol === ':' || protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:' || protocol === 'tel:';\n    }\n\n    return true;\n  }\n  /**\n   * Verify that an HTML tag is allowed to render.\n   */\n  ;\n\n  _proto3.isTagAllowed = function isTagAllowed(tagName) {\n    if (this.banned.has(tagName) || this.blocked.has(tagName)) {\n      return false;\n    }\n\n    return this.props.allowElements || this.allowed.has(tagName);\n  }\n  /**\n   * Parse the markup by injecting it into a detached document,\n   * while looping over all child nodes and generating an\n   * array to interpolate into JSX.\n   */\n  ;\n\n  _proto3.parse = function parse() {\n    if (!this.container) {\n      return [];\n    }\n\n    return this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n  }\n  /**\n   * Loop over the nodes children and generate a\n   * list of text nodes and React elements.\n   */\n  ;\n\n  _proto3.parseNode = function parseNode(parentNode, parentConfig) {\n    var _this3 = this;\n\n    var _this$props2 = this.props,\n        noHtml = _this$props2.noHtml,\n        noHtmlExceptMatchers = _this$props2.noHtmlExceptMatchers,\n        allowElements = _this$props2.allowElements,\n        transform = _this$props2.transform,\n        transformOnlyAllowList = _this$props2.transformOnlyAllowList;\n    var content = [];\n    var mergedText = '';\n    Array.from(parentNode.childNodes).forEach(function (node) {\n      // Create React elements from HTML elements\n      if (node.nodeType === ELEMENT_NODE) {\n        var tagName = node.nodeName.toLowerCase();\n\n        var config = _this3.getTagConfig(tagName); // Persist any previous text\n\n\n        if (mergedText) {\n          content.push(mergedText);\n          mergedText = '';\n        } // Apply node filters first\n\n\n        var nextNode = _this3.applyNodeFilters(tagName, node);\n\n        if (!nextNode) {\n          return;\n        } // Apply transformation second\n\n\n        var children;\n\n        if (transform && !(transformOnlyAllowList && !_this3.isTagAllowed(tagName))) {\n          _this3.keyIndex += 1;\n          var key = _this3.keyIndex; // Must occur after key is set\n\n          children = _this3.parseNode(nextNode, config);\n          var transformed = transform(nextNode, children, config);\n\n          if (transformed === null) {\n            return;\n          } else if (typeof transformed !== 'undefined') {\n            content.push( /*#__PURE__*/React.cloneElement(transformed, {\n              key: key\n            }));\n            return;\n          } // Reset as we're not using the transformation\n\n\n          _this3.keyIndex = key - 1;\n        } // Never allow these tags (except via a transformer)\n\n\n        if (_this3.banned.has(tagName)) {\n          return;\n        } // Only render when the following criteria is met:\n        //  - HTML has not been disabled\n        //  - Tag is allowed\n        //  - Child is valid within the parent\n\n\n        if (!(noHtml || noHtmlExceptMatchers && tagName !== 'br') && _this3.isTagAllowed(tagName) && (allowElements || _this3.canRenderChild(parentConfig, config))) {\n          _this3.keyIndex += 1; // Build the props as it makes it easier to test\n\n          var attributes = _this3.extractAttributes(nextNode);\n\n          var elementProps = {\n            tagName: tagName\n          };\n\n          if (attributes) {\n            elementProps.attributes = attributes;\n          }\n\n          if (config.void) {\n            elementProps.selfClose = config.void;\n          }\n\n          content.push( /*#__PURE__*/React.createElement(Element, _extends2({}, elementProps, {\n            key: _this3.keyIndex\n          }), children || _this3.parseNode(nextNode, config))); // Render the children of the current element only.\n          // Important: If the current element is not allowed,\n          // use the parent element for the next scope.\n        } else {\n          content = content.concat(_this3.parseNode(nextNode, config.tagName ? config : parentConfig));\n        } // Apply matchers if a text node\n\n      } else if (node.nodeType === TEXT_NODE) {\n        var text = noHtml && !noHtmlExceptMatchers ? node.textContent : _this3.applyMatchers(node.textContent || '', parentConfig);\n\n        if (Array.isArray(text)) {\n          content = content.concat(text);\n        } else {\n          mergedText += text;\n        }\n      }\n    });\n\n    if (mergedText) {\n      content.push(mergedText);\n    }\n\n    return content;\n  }\n  /**\n   * Deconstruct the string into an array, by replacing custom tokens with React elements,\n   * so that React can render it correctly.\n   */\n  ;\n\n  _proto3.replaceTokens = function replaceTokens(tokenizedString, elements) {\n    if (!tokenizedString.includes('{{{')) {\n      return tokenizedString;\n    }\n\n    var nodes = [];\n    var text = tokenizedString;\n    var open = null; // Find an open token tag\n\n    while (open = text.match(OPEN_TOKEN)) {\n      var _open = open,\n          _match2 = _open[0],\n          tokenName = _open[1];\n      var startIndex = open.index;\n\n      var isVoid = _match2.includes('/');\n\n      if (process.env.NODE_ENV !== \"production\") {\n        if (!elements[tokenName]) {\n          throw new Error(\"Token \\\"\" + tokenName + \"\\\" found but no matching element to replace with.\");\n        }\n      } // Extract the previous non-token text\n\n\n      if (startIndex > 0) {\n        nodes.push(text.slice(0, startIndex)); // Reduce text so that the closing tag will be found after the opening\n\n        text = text.slice(startIndex);\n      }\n\n      var _elements$tokenName = elements[tokenName],\n          children = _elements$tokenName.children,\n          matcher = _elements$tokenName.matcher,\n          elementProps = _elements$tokenName.props;\n      var endIndex = void 0; // Use tag as-is if void\n\n      if (isVoid) {\n        endIndex = _match2.length;\n        nodes.push(matcher.createElement(children, elementProps)); // Find the closing tag if not void\n      } else {\n        var close = text.match(new RegExp(\"{{{/\" + tokenName + \"}}}\"));\n\n        if (process.env.NODE_ENV !== \"production\") {\n          if (!close) {\n            throw new Error(\"Closing token missing for interpolated element \\\"\" + tokenName + \"\\\".\");\n          }\n        }\n\n        endIndex = close.index + close[0].length;\n        nodes.push(matcher.createElement(this.replaceTokens(text.slice(_match2.length, close.index), elements), elementProps));\n      } // Reduce text for the next interation\n\n\n      text = text.slice(endIndex);\n    } // Extra the remaining text\n\n\n    if (text.length > 0) {\n      nodes.push(text);\n    } // Reduce to a string if possible\n\n\n    if (nodes.length === 0) {\n      return '';\n    } else if (nodes.length === 1 && typeof nodes[0] === 'string') {\n      return nodes[0];\n    }\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n/* eslint-disable react/jsx-fragments */\n\n\nfunction Markup(props) {\n  var attributes = props.attributes,\n      className = props.className,\n      containerTagName = props.containerTagName,\n      content = props.content,\n      emptyContent = props.emptyContent,\n      parsedContent = props.parsedContent,\n      tagName = props.tagName;\n  var tag = containerTagName || tagName || 'span';\n  var noWrap = tag === 'fragment' ? true : props.noWrap;\n  var mainContent;\n\n  if (parsedContent) {\n    mainContent = parsedContent;\n  } else {\n    var markup = new Parser(content || '', props).parse();\n\n    if (markup.length > 0) {\n      mainContent = markup;\n    }\n  }\n\n  if (!mainContent) {\n    mainContent = emptyContent;\n  }\n\n  if (noWrap) {\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return /*#__PURE__*/React.createElement(React.Fragment, null, mainContent);\n  }\n\n  return /*#__PURE__*/React.createElement(Element, {\n    attributes: attributes,\n    className: className,\n    tagName: tag\n  }, mainContent);\n}\n\nfunction Interweave(props) {\n  var attributes = props.attributes,\n      className = props.className,\n      _props$content = props.content,\n      content = _props$content === void 0 ? '' : _props$content,\n      _props$disableFilters = props.disableFilters,\n      disableFilters = _props$disableFilters === void 0 ? false : _props$disableFilters,\n      _props$disableMatcher = props.disableMatchers,\n      disableMatchers = _props$disableMatcher === void 0 ? false : _props$disableMatcher,\n      _props$emptyContent = props.emptyContent,\n      emptyContent = _props$emptyContent === void 0 ? null : _props$emptyContent,\n      _props$filters = props.filters,\n      filters = _props$filters === void 0 ? [] : _props$filters,\n      _props$matchers = props.matchers,\n      matchers = _props$matchers === void 0 ? [] : _props$matchers,\n      _props$onAfterParse = props.onAfterParse,\n      onAfterParse = _props$onAfterParse === void 0 ? null : _props$onAfterParse,\n      _props$onBeforeParse = props.onBeforeParse,\n      onBeforeParse = _props$onBeforeParse === void 0 ? null : _props$onBeforeParse,\n      _props$tagName = props.tagName,\n      tagName = _props$tagName === void 0 ? 'span' : _props$tagName,\n      _props$noWrap = props.noWrap,\n      noWrap = _props$noWrap === void 0 ? false : _props$noWrap,\n      parserProps = _objectWithoutPropertiesLoose(props, [\"attributes\", \"className\", \"content\", \"disableFilters\", \"disableMatchers\", \"emptyContent\", \"filters\", \"matchers\", \"onAfterParse\", \"onBeforeParse\", \"tagName\", \"noWrap\"]);\n\n  var allMatchers = disableMatchers ? [] : matchers;\n  var allFilters = disableFilters ? [] : filters;\n  var beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n  var afterCallbacks = onAfterParse ? [onAfterParse] : []; // Inherit callbacks from matchers\n\n  allMatchers.forEach(function (matcher) {\n    if (matcher.onBeforeParse) {\n      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n    }\n\n    if (matcher.onAfterParse) {\n      afterCallbacks.push(matcher.onAfterParse.bind(matcher));\n    }\n  }); // Trigger before callbacks\n\n  var markup = beforeCallbacks.reduce(function (string, callback) {\n    var nextString = callback(string, props);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof nextString !== 'string') {\n        throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n      }\n    }\n\n    return nextString;\n  }, content || ''); // Parse the markup\n\n  var parser = new Parser(markup, parserProps, allMatchers, allFilters); // Trigger after callbacks\n\n  var nodes = afterCallbacks.reduce(function (parserNodes, callback) {\n    var nextNodes = callback(parserNodes, props);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(nextNodes)) {\n        throw new TypeError('Interweave `onAfterParse` must return an array of strings and React elements.');\n      }\n    }\n\n    return nextNodes;\n  }, parser.parse());\n  return /*#__PURE__*/React.createElement(Markup, {\n    attributes: attributes,\n    className: className,\n    containerTagName: props.containerTagName,\n    emptyContent: emptyContent,\n    tagName: tagName,\n    noWrap: noWrap,\n    parsedContent: nodes.length === 0 ? undefined : nodes\n  });\n}\n/**\n * Trigger the actual pattern match and package the matched\n * response through a callback.\n */\n\n\nfunction match(string, pattern, callback, isVoid) {\n  if (isVoid === void 0) {\n    isVoid = false;\n  }\n\n  var matches = string.match(pattern instanceof RegExp ? pattern : new RegExp(pattern, 'i'));\n\n  if (!matches) {\n    return null;\n  }\n\n  return _extends2({\n    match: matches[0],\n    void: isVoid\n  }, callback(matches), {\n    index: matches.index,\n    length: matches[0].length,\n    valid: true\n  });\n}\n\nvar Matcher = /*#__PURE__*/function () {\n  function Matcher(name, options, factory) {\n    this.greedy = false;\n    this.options = void 0;\n    this.propName = void 0;\n    this.inverseName = void 0;\n    this.factory = void 0;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!name || name.toLowerCase() === 'html') {\n        throw new Error(\"The matcher name \\\"\" + name + \"\\\" is not allowed.\");\n      }\n    } // @ts-expect-error\n\n\n    this.options = _extends2({}, options);\n    this.propName = name;\n    this.inverseName = \"no\" + (name.charAt(0).toUpperCase() + name.slice(1));\n    this.factory = factory || null;\n  }\n  /**\n   * Attempts to create a React element using a custom user provided factory,\n   * or the default matcher factory.\n   */\n\n\n  var _proto4 = Matcher.prototype;\n\n  _proto4.createElement = function createElement(children, props) {\n    var element = this.factory ? /*#__PURE__*/React.createElement(this.factory, props, children) : this.replaceWith(children, props);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof element !== 'string' && ! /*#__PURE__*/React.isValidElement(element)) {\n        throw new Error(\"Invalid React element created from \" + this.constructor.name + \".\");\n      }\n    }\n\n    return element;\n  }\n  /**\n   * Trigger the actual pattern match and package the matched\n   * response through a callback.\n   */\n  ;\n\n  _proto4.doMatch = function doMatch(string, pattern, callback, isVoid) {\n    if (isVoid === void 0) {\n      isVoid = false;\n    }\n\n    return match(string, pattern, callback, isVoid);\n  }\n  /**\n   * Callback triggered before parsing.\n   */\n  ;\n\n  _proto4.onBeforeParse = function onBeforeParse(content, props) {\n    return content;\n  }\n  /**\n   * Callback triggered after parsing.\n   */\n  ;\n\n  _proto4.onAfterParse = function onAfterParse(content, props) {\n    return content;\n  }\n  /**\n   * Replace the match with a React element based on the matched token and optional props.\n   */\n  ;\n\n  return Matcher;\n}();\n/**\n * @copyright   2016-2019, Miles Johnson\n * @license     https://opensource.org/licenses/MIT\n */\n\n\nexport default Interweave;\nexport { ALLOWED_TAG_LIST, ATTRIBUTES, ATTRIBUTES_TO_PROPS, BANNED_TAG_LIST, Element, FILTER_ALLOW, FILTER_CAST_BOOL, FILTER_CAST_NUMBER, FILTER_DENY, FILTER_NO_CAST, Filter, Markup, Matcher, Parser, TAGS, TYPE_EMBEDDED, TYPE_FLOW, TYPE_HEADING, TYPE_INTERACTIVE, TYPE_PALPABLE, TYPE_PHRASING, TYPE_SECTION, match };","map":{"version":3,"mappings":"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","names":["Element","attributes","children","arguments","selfClose","_ref","_ref$attributes","className","Filter","tagName","attribute","name","_proto","TYPE_EMBEDDED","node","_node","TYPE_INTERACTIVE","tagConfigs","a","content","self","address","invalid","TYPE_PHRASING","audio","TYPE_PALPABLE","type","TYPE_FLOW","void","body","button","caption","br","col","parent","colgroup","details","header","dt","img","main","ol","picture","li","rp","rt","rtc","ruby","source","summary","table","tbody","tfoot","thead","track","video","tr","wbr","ul","forEach","createConfigBuilder","config","TYPE_SECTION","TYPE_HEADING","freeze","BANNED_TAG_LIST","FILTER_ALLOW","FILTER_DENY","FILTER_CAST_BOOL","FILTER_NO_CAST","ATTRIBUTES","cite","class","Object","colspan","tag","FILTER_CAST_NUMBER","controls","default","disabled","dir","height","href","id","label","lang","loading","loop","media","muted","poster","role","rowspan","scope","sizes","span","start","style","src","srclang","srcset","target","title","width","ATTRIBUTES_TO_PROPS","datetime","INVALID_STYLES","StyleFilter","value","key","match","ELEMENT_NODE","TEXT_NODE","apply","OPEN_TOKEN","_proto2","createDocument","window","document","undefined","allowed","banned","container","props","keyIndex","constructor","markup","createHTMLDocument","blocked","blockList","applyAttributeFilters","filters","applyNodeFilters","applyMatchers","matchers","matchedString","concat","string","elementIndex","parts","matcher","allowList","ALLOWED_TAG_LIST","Set","getTagConfig","canRenderChild","_proto3","index","valid","partProps","filter","nextNode","tokenizedString","parentConfig","elements","length","_parts","isVoid","tokenName","replaceTokens","childConfig","_this","_match","includes","slice","convertLineBreaks","noHtml","nextMarkup","replace","createContainer","doc","el","createElement","disableLineBreaks","Array","attr","newName","toLowerCase","global","allowAttributes","newValue","count","extractStyleAttribute","from","styles","common","Number","_this2","HTMLAnchorElement","letter","getAttribute","isTagAllowed","parse","parseNode","parentNode","noHtmlExceptMatchers","protocol","allowElements","transform","mergedText","push","React","cloneElement","transformed","transformOnlyAllowList","has","elementProps","nodeType","text","_this3","nodes","open","__DEV__","startIndex","endIndex","close","Markup","containerTagName","_elements$tokenName","emptyContent","parsedContent","noWrap","mainContent","Error","Parser","disableFilters","disableMatchers","onAfterParse","onBeforeParse","parserProps","allMatchers","allFilters","beforeCallbacks","afterCallbacks","nextString","parser","isArray","_props$content","TypeError","_props$disableFilters","_props$disableMatcher","_props$emptyContent","_props$filters","_props$matchers","_props$onAfterParse","_props$onBeforeParse","_props$noWrap","pattern","matches","bind","Matcher","options","NODE_ENV","propName","inverseName","factory","process","nextNodes","element","callback"],"sources":["/Users/lomda/Desktop/git-ptojects/race-for-the-army-lomda/node_modules/interweave/src/Element.tsx","/Users/lomda/Desktop/git-ptojects/race-for-the-army-lomda/node_modules/interweave/src/Filter.ts","/Users/lomda/Desktop/git-ptojects/race-for-the-army-lomda/node_modules/interweave/src/constants.ts","/Users/lomda/Desktop/git-ptojects/race-for-the-army-lomda/node_modules/interweave/src/StyleFilter.ts","/Users/lomda/Desktop/git-ptojects/race-for-the-army-lomda/node_modules/interweave/src/Parser.ts","/Users/lomda/Desktop/git-ptojects/race-for-the-army-lomda/node_modules/interweave/src/Markup.tsx","/Users/lomda/Desktop/git-ptojects/race-for-the-army-lomda/node_modules/interweave/src/Interweave.tsx","/Users/lomda/Desktop/git-ptojects/race-for-the-army-lomda/node_modules/interweave/src/match.ts","/Users/lomda/Desktop/git-ptojects/race-for-the-army-lomda/node_modules/interweave/src/Matcher.ts","/Users/lomda/Desktop/git-ptojects/race-for-the-army-lomda/node_modules/interweave/src/index.ts"],"sourcesContent":["import React from 'react';\nimport { ElementProps } from './types';\n\nexport default function Element({\n  attributes = {},\n  className,\n  children = null,\n  selfClose = false,\n  tagName,\n}: ElementProps) {\n  const Tag = tagName as 'span';\n\n  return selfClose ? (\n    <Tag className={className} {...attributes} />\n  ) : (\n    <Tag className={className} {...attributes}>\n      {children}\n    </Tag>\n  );\n}\n","import { ElementAttributes, FilterInterface } from './types';\n\nexport default class Filter implements FilterInterface {\n  /**\n   * Filter and clean an HTML attribute value.\n   */\n  attribute<K extends keyof ElementAttributes>(\n    name: K,\n    value: ElementAttributes[K],\n  ): ElementAttributes[K] | null | undefined {\n    return value;\n  }\n\n  /**\n   * Filter and clean an HTML node.\n   */\n  node(name: string, node: HTMLElement): HTMLElement | null {\n    return node;\n  }\n}\n","/* eslint-disable no-bitwise, no-magic-numbers, sort-keys */\n\nimport { ConfigMap, FilterMap, NodeConfig } from './types';\n\n// https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories\nexport const TYPE_FLOW = 1;\nexport const TYPE_SECTION = 1 << 1;\nexport const TYPE_HEADING = 1 << 2;\nexport const TYPE_PHRASING = 1 << 3;\nexport const TYPE_EMBEDDED = 1 << 4;\nexport const TYPE_INTERACTIVE = 1 << 5;\nexport const TYPE_PALPABLE = 1 << 6;\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst tagConfigs: { [tagName: string]: Partial<NodeConfig> } = {\n  a: {\n    content: TYPE_FLOW | TYPE_PHRASING,\n    self: false,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE,\n  },\n  address: {\n    invalid: [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'address',\n      'article',\n      'aside',\n      'section',\n      'div',\n      'header',\n      'footer',\n    ],\n    self: false,\n  },\n  audio: {\n    children: ['track', 'source'],\n  },\n  br: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true,\n  },\n  body: {\n    content:\n      TYPE_FLOW |\n      TYPE_SECTION |\n      TYPE_HEADING |\n      TYPE_PHRASING |\n      TYPE_EMBEDDED |\n      TYPE_INTERACTIVE |\n      TYPE_PALPABLE,\n  },\n  button: {\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE,\n  },\n  caption: {\n    content: TYPE_FLOW,\n    parent: ['table'],\n  },\n  col: {\n    parent: ['colgroup'],\n    void: true,\n  },\n  colgroup: {\n    children: ['col'],\n    parent: ['table'],\n  },\n  details: {\n    children: ['summary'],\n    type: TYPE_FLOW | TYPE_INTERACTIVE | TYPE_PALPABLE,\n  },\n  dd: {\n    content: TYPE_FLOW,\n    parent: ['dl'],\n  },\n  dl: {\n    children: ['dt', 'dd'],\n    type: TYPE_FLOW,\n  },\n  dt: {\n    content: TYPE_FLOW,\n    invalid: ['footer', 'header'],\n    parent: ['dl'],\n  },\n  figcaption: {\n    content: TYPE_FLOW,\n    parent: ['figure'],\n  },\n  footer: {\n    invalid: ['footer', 'header'],\n  },\n  header: {\n    invalid: ['footer', 'header'],\n  },\n  hr: {\n    type: TYPE_FLOW,\n    void: true,\n  },\n  img: {\n    void: true,\n  },\n  li: {\n    content: TYPE_FLOW,\n    parent: ['ul', 'ol', 'menu'],\n  },\n  main: {\n    self: false,\n  },\n  ol: {\n    children: ['li'],\n    type: TYPE_FLOW,\n  },\n  picture: {\n    children: ['source', 'img'],\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED,\n  },\n  rb: {\n    parent: ['ruby', 'rtc'],\n  },\n  rp: {\n    parent: ['ruby', 'rtc'],\n  },\n  rt: {\n    content: TYPE_PHRASING,\n    parent: ['ruby', 'rtc'],\n  },\n  rtc: {\n    content: TYPE_PHRASING,\n    parent: ['ruby'],\n  },\n  ruby: {\n    children: ['rb', 'rp', 'rt', 'rtc'],\n  },\n  source: {\n    parent: ['audio', 'video', 'picture'],\n    void: true,\n  },\n  summary: {\n    content: TYPE_PHRASING,\n    parent: ['details'],\n  },\n  table: {\n    children: ['caption', 'colgroup', 'thead', 'tbody', 'tfoot', 'tr'],\n    type: TYPE_FLOW,\n  },\n  tbody: {\n    parent: ['table'],\n    children: ['tr'],\n  },\n  td: {\n    content: TYPE_FLOW,\n    parent: ['tr'],\n  },\n  tfoot: {\n    parent: ['table'],\n    children: ['tr'],\n  },\n  th: {\n    content: TYPE_FLOW,\n    parent: ['tr'],\n  },\n  thead: {\n    parent: ['table'],\n    children: ['tr'],\n  },\n  tr: {\n    parent: ['table', 'tbody', 'thead', 'tfoot'],\n    children: ['th', 'td'],\n  },\n  track: {\n    parent: ['audio', 'video'],\n    void: true,\n  },\n  ul: {\n    children: ['li'],\n    type: TYPE_FLOW,\n  },\n  video: {\n    children: ['track', 'source'],\n  },\n  wbr: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true,\n  },\n};\n\nfunction createConfigBuilder(config: Partial<NodeConfig>): (tagName: string) => void {\n  return (tagName: string) => {\n    tagConfigs[tagName] = {\n      ...config,\n      ...tagConfigs[tagName],\n    };\n  };\n}\n\n['address', 'main', 'div', 'figure', 'p', 'pre'].forEach(\n  createConfigBuilder({\n    content: TYPE_FLOW,\n    type: TYPE_FLOW | TYPE_PALPABLE,\n  }),\n);\n\n[\n  'abbr',\n  'b',\n  'bdi',\n  'bdo',\n  'cite',\n  'code',\n  'data',\n  'dfn',\n  'em',\n  'i',\n  'kbd',\n  'mark',\n  'q',\n  'ruby',\n  'samp',\n  'strong',\n  'sub',\n  'sup',\n  'time',\n  'u',\n  'var',\n].forEach(\n  createConfigBuilder({\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_PALPABLE,\n  }),\n);\n\n['p', 'pre'].forEach(\n  createConfigBuilder({\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PALPABLE,\n  }),\n);\n\n['s', 'small', 'span', 'del', 'ins'].forEach(\n  createConfigBuilder({\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PHRASING,\n  }),\n);\n\n['article', 'aside', 'footer', 'header', 'nav', 'section', 'blockquote'].forEach(\n  createConfigBuilder({\n    content: TYPE_FLOW,\n    type: TYPE_FLOW | TYPE_SECTION | TYPE_PALPABLE,\n  }),\n);\n\n['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].forEach(\n  createConfigBuilder({\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_HEADING | TYPE_PALPABLE,\n  }),\n);\n\n['audio', 'canvas', 'iframe', 'img', 'video'].forEach(\n  createConfigBuilder({\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_PALPABLE,\n  }),\n);\n\n// Disable this map from being modified\nexport const TAGS: ConfigMap = Object.freeze(tagConfigs);\n\n// Tags that should never be allowed, even if the allow list is disabled\nexport const BANNED_TAG_LIST = [\n  'applet',\n  'base',\n  'body',\n  'command',\n  'embed',\n  'frame',\n  'frameset',\n  'head',\n  'html',\n  'link',\n  'meta',\n  'noscript',\n  'object',\n  'script',\n  'style',\n  'title',\n];\n\nexport const ALLOWED_TAG_LIST = Object.keys(TAGS).filter(\n  (tag) => tag !== 'canvas' && tag !== 'iframe',\n);\n\n// Filters apply to HTML attributes\nexport const FILTER_ALLOW = 1;\nexport const FILTER_DENY = 2;\nexport const FILTER_CAST_NUMBER = 3;\nexport const FILTER_CAST_BOOL = 4;\nexport const FILTER_NO_CAST = 5;\n\n// Attributes not listed here will be denied\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\nexport const ATTRIBUTES: FilterMap = Object.freeze({\n  alt: FILTER_ALLOW,\n  cite: FILTER_ALLOW,\n  class: FILTER_ALLOW,\n  colspan: FILTER_CAST_NUMBER,\n  controls: FILTER_CAST_BOOL,\n  datetime: FILTER_ALLOW,\n  default: FILTER_CAST_BOOL,\n  disabled: FILTER_CAST_BOOL,\n  dir: FILTER_ALLOW,\n  height: FILTER_ALLOW,\n  href: FILTER_ALLOW,\n  id: FILTER_ALLOW,\n  kind: FILTER_ALLOW,\n  label: FILTER_ALLOW,\n  lang: FILTER_ALLOW,\n  loading: FILTER_ALLOW,\n  loop: FILTER_CAST_BOOL,\n  media: FILTER_ALLOW,\n  muted: FILTER_CAST_BOOL,\n  poster: FILTER_ALLOW,\n  role: FILTER_ALLOW,\n  rowspan: FILTER_CAST_NUMBER,\n  scope: FILTER_ALLOW,\n  sizes: FILTER_ALLOW,\n  span: FILTER_CAST_NUMBER,\n  start: FILTER_CAST_NUMBER,\n  style: FILTER_NO_CAST,\n  src: FILTER_ALLOW,\n  srclang: FILTER_ALLOW,\n  srcset: FILTER_ALLOW,\n  target: FILTER_ALLOW,\n  title: FILTER_ALLOW,\n  type: FILTER_ALLOW,\n  width: FILTER_ALLOW,\n});\n\n// Attributes to camel case for React props\nexport const ATTRIBUTES_TO_PROPS: { [key: string]: string } = Object.freeze({\n  class: 'className',\n  colspan: 'colSpan',\n  datetime: 'dateTime',\n  rowspan: 'rowSpan',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n});\n","import Filter from './Filter';\nimport { ElementAttributes } from './types';\n\nconst INVALID_STYLES = /(url|image|image-set)\\(/i;\n\nexport default class StyleFilter extends Filter {\n  attribute<K extends keyof ElementAttributes>(\n    name: K,\n    value: ElementAttributes[K],\n  ): ElementAttributes[K] {\n    if (name === 'style') {\n      Object.keys(value).forEach((key) => {\n        if (String(value[key]).match(INVALID_STYLES)) {\n          // eslint-disable-next-line no-param-reassign\n          delete value[key];\n        }\n      });\n    }\n\n    return value;\n  }\n}\n","/* eslint-disable no-bitwise, no-cond-assign, complexity */\n\nimport React from 'react';\nimport escapeHtml from 'escape-html';\nimport {\n  ALLOWED_TAG_LIST,\n  ATTRIBUTES,\n  ATTRIBUTES_TO_PROPS,\n  BANNED_TAG_LIST,\n  FILTER_CAST_BOOL,\n  FILTER_CAST_NUMBER,\n  FILTER_DENY,\n  FILTER_NO_CAST,\n  TAGS,\n} from './constants';\nimport Element from './Element';\nimport StyleFilter from './StyleFilter';\nimport {\n  Attributes,\n  AttributeValue,\n  ChildrenNode,\n  ElementAttributes,\n  ElementProps,\n  FilterInterface,\n  MatcherElementsMap,\n  MatcherInterface,\n  Node,\n  NodeConfig,\n  ParserProps,\n} from './types';\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nconst ALLOWED_ATTRS = /^(aria-|data-|\\w+:)/iu;\nconst OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\n\nfunction createDocument() {\n  // Maybe SSR? Just do nothing instead of crashing!\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return undefined;\n  }\n\n  return document.implementation.createHTMLDocument('Interweave');\n}\n\nexport default class Parser {\n  allowed: Set<string>;\n\n  banned: Set<string>;\n\n  blocked: Set<string>;\n\n  container?: HTMLElement;\n\n  content: Node[] = [];\n\n  props: ParserProps;\n\n  matchers: MatcherInterface[];\n\n  filters: FilterInterface[];\n\n  keyIndex: number;\n\n  constructor(\n    markup: string,\n    props: ParserProps = {},\n    matchers: MatcherInterface[] = [],\n    filters: FilterInterface[] = [],\n  ) {\n    if (__DEV__) {\n      if (markup && typeof markup !== 'string') {\n        throw new TypeError('Interweave parser requires a valid string.');\n      }\n    }\n\n    this.props = props;\n    this.matchers = matchers;\n    this.filters = [...filters, new StyleFilter()];\n    this.keyIndex = -1;\n    this.container = this.createContainer(markup || '');\n    this.allowed = new Set(props.allowList || ALLOWED_TAG_LIST);\n    this.banned = new Set(BANNED_TAG_LIST);\n    this.blocked = new Set(props.blockList);\n  }\n\n  /**\n   * Loop through and apply all registered attribute filters.\n   */\n  applyAttributeFilters<K extends keyof ElementAttributes>(\n    name: K,\n    value: ElementAttributes[K],\n  ): ElementAttributes[K] {\n    return this.filters.reduce(\n      (nextValue, filter) =>\n        nextValue !== null && typeof filter.attribute === 'function'\n          ? filter.attribute(name, nextValue)\n          : nextValue,\n      value,\n    );\n  }\n\n  /**\n   * Loop through and apply all registered node filters.\n   */\n  applyNodeFilters(name: string, node: HTMLElement | null): HTMLElement | null {\n    // Allow null to be returned\n    return this.filters.reduce(\n      (nextNode, filter) =>\n        nextNode !== null && typeof filter.node === 'function'\n          ? filter.node(name, nextNode)\n          : nextNode,\n      node,\n    );\n  }\n\n  /**\n   * Loop through and apply all registered matchers to the string.\n   * If a match is found, create a React element, and build a new array.\n   * This array allows React to interpolate and render accordingly.\n   */\n  applyMatchers(string: string, parentConfig: NodeConfig): ChildrenNode {\n    const elements: MatcherElementsMap = {};\n    const { props } = this;\n    let matchedString = string;\n    let elementIndex = 0;\n    let parts = null;\n\n    this.matchers.forEach((matcher) => {\n      const tagName = matcher.asTag().toLowerCase();\n      const config = this.getTagConfig(tagName);\n\n      // Skip matchers that have been disabled from props or are not supported\n      if (\n        (props as { [key: string]: unknown })[matcher.inverseName] ||\n        !this.isTagAllowed(tagName)\n      ) {\n        return;\n      }\n\n      // Skip matchers in which the child cannot be rendered\n      if (!this.canRenderChild(parentConfig, config)) {\n        return;\n      }\n\n      // Continuously trigger the matcher until no matches are found\n      let tokenizedString = '';\n\n      while (matchedString && (parts = matcher.match(matchedString))) {\n        const { index, length, match, valid, void: isVoid, ...partProps } = parts;\n        const tokenName = matcher.propName + elementIndex;\n\n        // Piece together a new string with interpolated tokens\n        if (index > 0) {\n          tokenizedString += matchedString.slice(0, index);\n        }\n\n        if (valid) {\n          tokenizedString += isVoid\n            ? `{{{${tokenName}/}}}`\n            : `{{{${tokenName}}}}${match}{{{/${tokenName}}}}`;\n\n          this.keyIndex += 1;\n\n          elementIndex += 1;\n          elements[tokenName] = {\n            children: match,\n            matcher,\n            props: {\n              ...props,\n              ...partProps,\n              key: this.keyIndex,\n            },\n          };\n        } else {\n          tokenizedString += match;\n        }\n\n        // Reduce the string being matched against,\n        // otherwise we end up in an infinite loop!\n        if (matcher.greedy) {\n          matchedString = tokenizedString + matchedString.slice(index + length);\n          tokenizedString = '';\n        } else {\n          // eslint-disable-next-line unicorn/explicit-length-check\n          matchedString = matchedString.slice(index + (length || match.length));\n        }\n      }\n\n      // Update the matched string with the tokenized string,\n      // so that the next matcher can apply to it.\n      if (!matcher.greedy) {\n        matchedString = tokenizedString + matchedString;\n      }\n    });\n\n    if (elementIndex === 0) {\n      return string;\n    }\n\n    return this.replaceTokens(matchedString, elements);\n  }\n\n  /**\n   * Determine whether the child can be rendered within the parent.\n   */\n  canRenderChild(parentConfig: NodeConfig, childConfig: NodeConfig): boolean {\n    if (!parentConfig.tagName || !childConfig.tagName) {\n      return false;\n    }\n\n    // No children\n    if (parentConfig.void) {\n      return false;\n    }\n\n    // Valid children\n    if (parentConfig.children.length > 0) {\n      return parentConfig.children.includes(childConfig.tagName);\n    }\n\n    if (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n      return false;\n    }\n\n    // Valid parent\n    if (childConfig.parent.length > 0) {\n      return childConfig.parent.includes(parentConfig.tagName);\n    }\n\n    // Self nesting\n    if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n      return false;\n    }\n\n    // Content category type\n    return Boolean(parentConfig && parentConfig.content & childConfig.type);\n  }\n\n  /**\n   * Convert line breaks in a string to HTML `<br/>` tags.\n   * If the string contains HTML, we should not convert anything,\n   * as line breaks should be handled by `<br/>`s in the markup itself.\n   */\n  convertLineBreaks(markup: string): string {\n    const { noHtml, disableLineBreaks } = this.props;\n\n    if (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n      return markup;\n    }\n\n    // Replace carriage returns\n    let nextMarkup = markup.replace(/\\r\\n/g, '\\n');\n\n    // Replace long line feeds\n    nextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n');\n\n    // Replace line feeds with `<br/>`s\n    nextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n\n    return nextMarkup;\n  }\n\n  /**\n   * Create a detached HTML document that allows for easy HTML\n   * parsing while not triggering scripts or loading external\n   * resources.\n   */\n  createContainer(markup: string): HTMLElement | undefined {\n    const factory =\n      (typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL) || createDocument;\n    const doc = factory();\n\n    if (!doc) {\n      return undefined;\n    }\n\n    const tag = this.props.containerTagName || 'body';\n    const el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n\n    if (markup.match(INVALID_ROOTS)) {\n      if (__DEV__) {\n        throw new Error('HTML documents as Interweave content are not supported.');\n      }\n    } else {\n      el.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n    }\n\n    return el;\n  }\n\n  /**\n   * Convert an elements attribute map to an object map.\n   * Returns null if no attributes are defined.\n   */\n  extractAttributes(node: HTMLElement): Attributes | null {\n    const { allowAttributes } = this.props;\n    const attributes: Attributes = {};\n    let count = 0;\n\n    if (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n      return null;\n    }\n\n    Array.from(node.attributes).forEach((attr) => {\n      const { name, value } = attr;\n      const newName = name.toLowerCase();\n      const filter = ATTRIBUTES[newName] || ATTRIBUTES[name];\n\n      // Verify the node is safe from attacks\n      if (!this.isSafe(node)) {\n        return;\n      }\n\n      // Do not allow denied attributes, excluding ARIA attributes\n      // Do not allow events or XSS injections\n      if (!newName.match(ALLOWED_ATTRS)) {\n        if (\n          (!allowAttributes && (!filter || filter === FILTER_DENY)) ||\n          newName.startsWith('on') ||\n          value.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i)\n        ) {\n          return;\n        }\n      }\n\n      // Apply attribute filters\n      let newValue: AttributeValue = newName === 'style' ? this.extractStyleAttribute(node) : value;\n\n      // Cast to boolean\n      if (filter === FILTER_CAST_BOOL) {\n        newValue = true;\n\n        // Cast to number\n      } else if (filter === FILTER_CAST_NUMBER) {\n        newValue = Number.parseFloat(String(newValue));\n\n        // Cast to string\n      } else if (filter !== FILTER_NO_CAST) {\n        newValue = String(newValue);\n      }\n\n      attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = this.applyAttributeFilters(\n        newName as keyof ElementAttributes,\n        newValue,\n      ) as AttributeValue;\n      count += 1;\n    });\n\n    if (count === 0) {\n      return null;\n    }\n\n    return attributes;\n  }\n\n  /**\n   * Extract the style attribute as an object and remove values that allow for attack vectors.\n   */\n  extractStyleAttribute(node: HTMLElement): object {\n    const styles: { [key: string]: number | string } = {};\n\n    Array.from(node.style).forEach((key) => {\n      const value = node.style[key as keyof CSSStyleDeclaration];\n\n      if (typeof value === 'string' || typeof value === 'number') {\n        styles[key.replace(/-([a-z])/g, (match, letter) => letter.toUpperCase())] = value;\n      }\n    });\n\n    return styles;\n  }\n\n  /**\n   * Return configuration for a specific tag.\n   */\n  getTagConfig(tagName: string): NodeConfig {\n    const common = {\n      children: [],\n      content: 0,\n      invalid: [],\n      parent: [],\n      self: true,\n      tagName: '',\n      type: 0,\n      void: false,\n    };\n\n    // Only spread when a tag config exists,\n    // otherwise we use the empty `tagName`\n    // for parent config inheritance.\n    if (TAGS[tagName]) {\n      return {\n        ...common,\n        ...TAGS[tagName],\n        tagName,\n      };\n    }\n\n    return common;\n  }\n\n  /**\n   * Verify that a node is safe from XSS and injection attacks.\n   */\n  isSafe(node: HTMLElement): boolean {\n    // URLs should only support HTTP, email and phone numbers\n    if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n      const href = node.getAttribute('href');\n\n      // Fragment protocols start with about:\n      // So let's just allow them\n      if (href && href.charAt(0) === '#') {\n        return true;\n      }\n\n      const protocol = node.protocol.toLowerCase();\n\n      return (\n        protocol === ':' ||\n        protocol === 'http:' ||\n        protocol === 'https:' ||\n        protocol === 'mailto:' ||\n        protocol === 'tel:'\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Verify that an HTML tag is allowed to render.\n   */\n  isTagAllowed(tagName: string): boolean {\n    if (this.banned.has(tagName) || this.blocked.has(tagName)) {\n      return false;\n    }\n\n    return this.props.allowElements || this.allowed.has(tagName);\n  }\n\n  /**\n   * Parse the markup by injecting it into a detached document,\n   * while looping over all child nodes and generating an\n   * array to interpolate into JSX.\n   */\n  parse(): Node[] {\n    if (!this.container) {\n      return [];\n    }\n\n    return this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n  }\n\n  /**\n   * Loop over the nodes children and generate a\n   * list of text nodes and React elements.\n   */\n  parseNode(parentNode: HTMLElement, parentConfig: NodeConfig): Node[] {\n    const {\n      noHtml,\n      noHtmlExceptMatchers,\n      allowElements,\n      transform,\n      transformOnlyAllowList,\n    } = this.props;\n    let content: Node[] = [];\n    let mergedText = '';\n\n    Array.from(parentNode.childNodes).forEach((node) => {\n      // Create React elements from HTML elements\n      if (node.nodeType === ELEMENT_NODE) {\n        const tagName = node.nodeName.toLowerCase();\n        const config = this.getTagConfig(tagName);\n\n        // Persist any previous text\n        if (mergedText) {\n          content.push(mergedText);\n          mergedText = '';\n        }\n\n        // Apply node filters first\n        const nextNode = this.applyNodeFilters(tagName, node as HTMLElement);\n\n        if (!nextNode) {\n          return;\n        }\n\n        // Apply transformation second\n        let children;\n\n        if (transform && !(transformOnlyAllowList && !this.isTagAllowed(tagName))) {\n          this.keyIndex += 1;\n          const key = this.keyIndex;\n\n          // Must occur after key is set\n          children = this.parseNode(nextNode, config);\n\n          const transformed = transform(nextNode, children, config);\n\n          if (transformed === null) {\n            return;\n          } else if (typeof transformed !== 'undefined') {\n            content.push(React.cloneElement(transformed as React.ReactElement<unknown>, { key }));\n\n            return;\n          }\n\n          // Reset as we're not using the transformation\n          this.keyIndex = key - 1;\n        }\n\n        // Never allow these tags (except via a transformer)\n        if (this.banned.has(tagName)) {\n          return;\n        }\n\n        // Only render when the following criteria is met:\n        //  - HTML has not been disabled\n        //  - Tag is allowed\n        //  - Child is valid within the parent\n        if (\n          !(noHtml || (noHtmlExceptMatchers && tagName !== 'br')) &&\n          this.isTagAllowed(tagName) &&\n          (allowElements || this.canRenderChild(parentConfig, config))\n        ) {\n          this.keyIndex += 1;\n\n          // Build the props as it makes it easier to test\n          const attributes = this.extractAttributes(nextNode);\n          const elementProps: ElementProps = {\n            tagName,\n          };\n\n          if (attributes) {\n            elementProps.attributes = attributes;\n          }\n\n          if (config.void) {\n            elementProps.selfClose = config.void;\n          }\n\n          content.push(\n            React.createElement(\n              Element,\n              { ...elementProps, key: this.keyIndex },\n              children || this.parseNode(nextNode, config),\n            ),\n          );\n\n          // Render the children of the current element only.\n          // Important: If the current element is not allowed,\n          // use the parent element for the next scope.\n        } else {\n          content = content.concat(\n            this.parseNode(nextNode, config.tagName ? config : parentConfig),\n          );\n        }\n\n        // Apply matchers if a text node\n      } else if (node.nodeType === TEXT_NODE) {\n        const text =\n          noHtml && !noHtmlExceptMatchers\n            ? node.textContent\n            : this.applyMatchers(node.textContent || '', parentConfig);\n\n        if (Array.isArray(text)) {\n          content = content.concat(text);\n        } else {\n          mergedText += text;\n        }\n      }\n    });\n\n    if (mergedText) {\n      content.push(mergedText);\n    }\n\n    return content;\n  }\n\n  /**\n   * Deconstruct the string into an array, by replacing custom tokens with React elements,\n   * so that React can render it correctly.\n   */\n  replaceTokens(tokenizedString: string, elements: MatcherElementsMap): ChildrenNode {\n    if (!tokenizedString.includes('{{{')) {\n      return tokenizedString;\n    }\n\n    const nodes: Node[] = [];\n    let text = tokenizedString;\n    let open: RegExpMatchArray | null = null;\n\n    // Find an open token tag\n    while ((open = text.match(OPEN_TOKEN))) {\n      const [match, tokenName] = open;\n      const startIndex = open.index!;\n      const isVoid = match.includes('/');\n\n      if (__DEV__) {\n        if (!elements[tokenName]) {\n          throw new Error(`Token \"${tokenName}\" found but no matching element to replace with.`);\n        }\n      }\n\n      // Extract the previous non-token text\n      if (startIndex > 0) {\n        nodes.push(text.slice(0, startIndex));\n\n        // Reduce text so that the closing tag will be found after the opening\n        text = text.slice(startIndex);\n      }\n\n      const { children, matcher, props: elementProps } = elements[tokenName];\n      let endIndex: number;\n\n      // Use tag as-is if void\n      if (isVoid) {\n        endIndex = match.length;\n\n        nodes.push(matcher.createElement(children, elementProps));\n\n        // Find the closing tag if not void\n      } else {\n        const close = text.match(new RegExp(`{{{/${tokenName}}}}`))!;\n\n        if (__DEV__) {\n          if (!close) {\n            throw new Error(`Closing token missing for interpolated element \"${tokenName}\".`);\n          }\n        }\n\n        endIndex = close.index! + close[0].length;\n\n        nodes.push(\n          matcher.createElement(\n            this.replaceTokens(text.slice(match.length, close.index!), elements),\n            elementProps,\n          ),\n        );\n      }\n\n      // Reduce text for the next interation\n      text = text.slice(endIndex);\n    }\n\n    // Extra the remaining text\n    if (text.length > 0) {\n      nodes.push(text);\n    }\n\n    // Reduce to a string if possible\n    if (nodes.length === 0) {\n      return '';\n    } else if (nodes.length === 1 && typeof nodes[0] === 'string') {\n      return nodes[0];\n    }\n\n    return nodes;\n  }\n}\n","/* eslint-disable react/jsx-fragments */\n\nimport React from 'react';\nimport Element from './Element';\nimport Parser from './Parser';\nimport { MarkupProps } from './types';\n\nexport default function Markup(props: MarkupProps) {\n  const {\n    attributes,\n    className,\n    containerTagName,\n    content,\n    emptyContent,\n    parsedContent,\n    tagName,\n  } = props;\n  const tag = containerTagName || tagName || 'span';\n  const noWrap = tag === 'fragment' ? true : props.noWrap;\n  let mainContent;\n\n  if (parsedContent) {\n    mainContent = parsedContent;\n  } else {\n    const markup = new Parser(content || '', props).parse();\n\n    if (markup.length > 0) {\n      mainContent = markup;\n    }\n  }\n\n  if (!mainContent) {\n    mainContent = emptyContent;\n  }\n\n  if (noWrap) {\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return <React.Fragment>{mainContent}</React.Fragment>;\n  }\n\n  return (\n    <Element attributes={attributes} className={className} tagName={tag}>\n      {mainContent}\n    </Element>\n  );\n}\n","import React from 'react';\nimport Markup from './Markup';\nimport Parser from './Parser';\nimport { InterweaveProps } from './types';\n\nexport default function Interweave(props: InterweaveProps) {\n  const {\n    attributes,\n    className,\n    content = '',\n    disableFilters = false,\n    disableMatchers = false,\n    emptyContent = null,\n    filters = [],\n    matchers = [],\n    onAfterParse = null,\n    onBeforeParse = null,\n    tagName = 'span',\n    noWrap = false,\n    ...parserProps\n  } = props;\n  const allMatchers = disableMatchers ? [] : matchers;\n  const allFilters = disableFilters ? [] : filters;\n  const beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n  const afterCallbacks = onAfterParse ? [onAfterParse] : [];\n\n  // Inherit callbacks from matchers\n  allMatchers.forEach((matcher) => {\n    if (matcher.onBeforeParse) {\n      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n    }\n\n    if (matcher.onAfterParse) {\n      afterCallbacks.push(matcher.onAfterParse.bind(matcher));\n    }\n  });\n\n  // Trigger before callbacks\n  const markup = beforeCallbacks.reduce((string, callback) => {\n    const nextString = callback(string, props);\n\n    if (__DEV__) {\n      if (typeof nextString !== 'string') {\n        throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n      }\n    }\n\n    return nextString;\n  }, content || '');\n\n  // Parse the markup\n  const parser = new Parser(markup, parserProps, allMatchers, allFilters);\n\n  // Trigger after callbacks\n  const nodes = afterCallbacks.reduce((parserNodes, callback) => {\n    const nextNodes = callback(parserNodes, props);\n\n    if (__DEV__) {\n      if (!Array.isArray(nextNodes)) {\n        throw new TypeError(\n          'Interweave `onAfterParse` must return an array of strings and React elements.',\n        );\n      }\n    }\n\n    return nextNodes;\n  }, parser.parse());\n\n  return (\n    <Markup\n      attributes={attributes}\n      className={className}\n      containerTagName={props.containerTagName}\n      emptyContent={emptyContent}\n      tagName={tagName}\n      noWrap={noWrap}\n      parsedContent={nodes.length === 0 ? undefined : nodes}\n    />\n  );\n}\n","import { MatchCallback, MatchResponse } from './types';\n\n/**\n * Trigger the actual pattern match and package the matched\n * response through a callback.\n */\nexport default function match<T>(\n  string: string,\n  pattern: RegExp | string,\n  callback: MatchCallback<T>,\n  isVoid: boolean = false,\n): MatchResponse<T> | null {\n  const matches = string.match(pattern instanceof RegExp ? pattern : new RegExp(pattern, 'i'));\n\n  if (!matches) {\n    return null;\n  }\n\n  return {\n    match: matches[0],\n    void: isVoid,\n    ...callback(matches),\n    index: matches.index!,\n    length: matches[0].length,\n    valid: true,\n  };\n}\n","import React from 'react';\nimport match from './match';\nimport { ChildrenNode, MatchCallback, MatcherInterface, MatchResponse, Node } from './types';\n\nexport default abstract class Matcher<Props extends object = {}, Options extends object = {}>\n  implements MatcherInterface<Props> {\n  greedy: boolean = false;\n\n  options: Options;\n\n  propName: string;\n\n  inverseName: string;\n\n  factory: React.ComponentType<Props> | null;\n\n  constructor(name: string, options?: Options, factory?: React.ComponentType<Props> | null) {\n    if (__DEV__) {\n      if (!name || name.toLowerCase() === 'html') {\n        throw new Error(`The matcher name \"${name}\" is not allowed.`);\n      }\n    }\n\n    // @ts-expect-error\n    this.options = { ...options };\n    this.propName = name;\n    this.inverseName = `no${name.charAt(0).toUpperCase() + name.slice(1)}`;\n    this.factory = factory || null;\n  }\n\n  /**\n   * Attempts to create a React element using a custom user provided factory,\n   * or the default matcher factory.\n   */\n  createElement(children: ChildrenNode, props: Props): Node {\n    const element = this.factory\n      ? React.createElement(this.factory, props, children)\n      : this.replaceWith(children, props);\n\n    if (__DEV__) {\n      if (typeof element !== 'string' && !React.isValidElement(element)) {\n        throw new Error(`Invalid React element created from ${this.constructor.name}.`);\n      }\n    }\n\n    return element;\n  }\n\n  /**\n   * Trigger the actual pattern match and package the matched\n   * response through a callback.\n   */\n  doMatch<T>(\n    string: string,\n    pattern: RegExp | string,\n    callback: MatchCallback<T>,\n    isVoid: boolean = false,\n  ): MatchResponse<T> | null {\n    return match(string, pattern, callback, isVoid);\n  }\n\n  /**\n   * Callback triggered before parsing.\n   */\n  onBeforeParse(content: string, props: Props): string {\n    return content;\n  }\n\n  /**\n   * Callback triggered after parsing.\n   */\n  onAfterParse(content: Node[], props: Props): Node[] {\n    return content;\n  }\n\n  /**\n   * Replace the match with a React element based on the matched token and optional props.\n   */\n  abstract replaceWith(children: ChildrenNode, props: Props): Node;\n\n  /**\n   * Defines the HTML tag name that the resulting React element will be.\n   */\n  abstract asTag(): string;\n\n  /**\n   * Attempt to match against the defined string. Return `null` if no match found,\n   * else return the `match` and any optional props to pass along.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  abstract match(string: string): MatchResponse<any> | null;\n}\n","/**\n * @copyright   2016-2019, Miles Johnson\n * @license     https://opensource.org/licenses/MIT\n */\n\nimport Element from './Element';\nimport Filter from './Filter';\nimport Interweave from './Interweave';\nimport Markup from './Markup';\nimport match from './match';\nimport Matcher from './Matcher';\nimport Parser from './Parser';\n\nexport { Element, Filter, Markup, match, Matcher, Parser };\n\nexport * from './constants';\nexport * from './types';\n\nexport default Interweave;\n"]},"metadata":{},"sourceType":"module"}